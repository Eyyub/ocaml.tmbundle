<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>beforeRunningCommand</key>
	<string>nop</string>
	<key>command</key>
	<string>#!/usr/bin/env ruby

$: &lt;&lt; ENV['TM_SUPPORT_PATH']

require 'lib/escape'


def parse_line(str)
	tokens = []
	current = ""
	instr = false
	escaped = false
	parenlevel = 0
	
	str.each_byte() do |b|
		c = b.chr()
		current &lt;&lt; c

		# token break
		if !instr and parenlevel == 0 and (c == ' ' or c == '\t')
			tokens &lt;&lt; current
			current = ""
		elsif !instr and c == '"'
			instr = true
		elsif instr and c == '\\'
			escaped = true
		elsif instr and escaped
		elsif instr and c == '"'
			instr = false
		elsif !instr and c == '('
			parenlevel += 1
		elsif !instr and c == ')'
			parenlevel -= 1
			if parenlevel == 0
				tokens &lt;&lt; ["("] + parse_line(current[/^\((.*)\)$/, 1]) + [")"]
				current = ""
			end
		end
	end
	tokens &lt;&lt; current
	
	tokens
end


def token_to_s(token)
	if token.kind_of?(String)
		token
	else
		token.flatten.join("")
	end
end


ENV['TM_TAB_SIZE'] = '2'
ENV['TM_SOFT_TABS'] = 'YES'

# generates a fill string consisting of as many tab characters as
# possible plus spaces to fill it out
def make_indent(length)
	if length.kind_of?(String)
		length = length.gsub(/\t/, " " * ENV['TM_TAB_SIZE'].to_i()).length()
	end
	
	if length &lt; 0 then length = 0 end
	fillsize = ENV['TM_TAB_SIZE'].to_i()
	fillchar = if ENV['TM_SOFT_TABS'] == 'YES' then " " * fillsize else "\t" end
	return (fillchar * (length / fillsize)) + " " * (length % fillsize)
end


def contains_unmatched_paren(str)
	parenlevel = 0
	instr = false
	escaped = false
	
	str.each_byte() do |b|
		c = b.chr()

		# token break
		if !instr and c == '"'
			instr = true
		elsif instr and c == '\\'
			escaped = true
		elsif instr and escaped
			# do nothing
		elsif instr and c == '"'
			instr = false
		elsif !instr and c == '('
			parenlevel += 1
		elsif !instr and c == ')'
			parenlevel -= 1
		end
	end
	
	if parenlevel &gt; 0
		true
	else
		false
	end
end


def make_multi_line(tokens, linelength = 78, currentindent = 0, line = "", lines = [])
	while tokens.length &gt; 0
		token = tokens[0]
		tokens = tokens[1..-1]
		tokenstr = token_to_s(token)
		
		if (line.length + tokenstr.length) &lt; (linelength - currentindent)
			line += tokenstr
		else
			lines &lt;&lt; line
			line = make_indent(currentindent)

			if token.kind_of?(String)
				line += tokenstr
				return make_multi_line(tokens, linelength, currentindent, line, lines)
			else
				line += token[0]
				newindent = currentindent
				if contains_unmatched_paren(line)
					newindent = newindent + ENV['TM_TAB_SIZE'].to_i()
				end
				lines = make_multi_line(token[1..-1], linelength, newindent, line, lines)
				line = lines[-1]
				lines = lines[0..-2]
			end
		end
	end
	lines &lt;&lt; line

	lines
end


line = $stdin.read()
indent = make_indent(line[/^\s*/])
fulllinelength = ENV['TM_COLUMNS'].to_i()
print e_sn(make_multi_line(parse_line(line[/\S.*$/]), fulllinelength, indent.length + ENV['TM_TAB_SIZE'].to_i, indent).join("\n"))</string>
	<key>disableOutputAutoIndent</key>
	<true/>
	<key>fallbackInput</key>
	<string>line</string>
	<key>input</key>
	<string>selection</string>
	<key>keyEquivalent</key>
	<string>^q</string>
	<key>name</key>
	<string>Wrap Line</string>
	<key>output</key>
	<string>insertAsSnippet</string>
	<key>scope</key>
	<string>source.ocaml</string>
	<key>uuid</key>
	<string>41481AFE-8B7C-4B7F-AECA-6725DADC0B27</string>
</dict>
</plist>
