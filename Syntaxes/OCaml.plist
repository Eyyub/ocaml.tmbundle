{
  // This syntox file is *mostly* correct per the 3.08.2 releose of the OCaml
  //  language specification.  Some things that I know are missing are proper
  // recognition of infix symbol functions, but I'm sure there's a few other
  // things that could be added e.g. the Pervasives and Standard Library function
  // names (though this might not be desirable...)
  //
  // Also note that I plan on adding extra support for OCamlyacc/lex/p4 in the future.
  //
  // William D. Neumann
  
	name = "OCaml Source";
	scopeName = "source.ocaml";
	uuid = "F816FA69-6EE8-11D9-BF2D-000D93589AF6";
	fileTypes = (ml, mli, mll, mly);
	foldingStartMarker = "\\<(struct|sig|object)\\>|\\(\\*\\*";
	foldingStopMarker = "\\<end\\>|\\*\\*\\)";
	increaseIndentPattern = "^.*(\\([^)\"']*|begin)$|\\<let\\s+[a-z][a-zA-Z0-9_']*.*(?!in$)|match\\s+.*\\s+with\\s*$|\\<(class|object|struct|sig)\\>";
	smartTypingPairs = (
	   ( "(", ")" ), ( "[", "]" ), ( "{", "}" ),
	   ( "\"", "\"" ), ( "'", "'" )
	);
	highlightPairs = (
	   ( "(", ")" ), ( "[", "]" ), ( "{", "}" )
	);
	foregroundColor = "#e0e0e0";
	backgroundColor = "#404040";
	patterns = (
  	{ name = "comment.ocaml.ocaml"; begin = "\\(\\*"; end = "\\*\\)"; swallow = "(\\(\\*.*\\*\\))+?"; fontStyle = ( italic ); foregroundColor = "#709070"; },
  	{ name = "comment.ocamlyacc.ocaml"; begin = "/\\*"; end = "\\*/"; swallow = "(/\\*.*\\*/)+?"; fontStyle = ( italic ); foregroundColor = "#709070"; },
		{ name = "keyword.language.ocaml"; match = "\\<(and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|false|for|fun|function|functor|if|in|include|inherit|initializer|land|lazy|let|lor|lsl|lsr|lxor|match|method|mod|module|mutable|new|object|of|open|or|private|rec|sig|struct|then|to|true|try|type|val|virtual|when|while|with)\\>"; fontStyle = ( bold ); foregroundColor = "#ffffa0"; },
		{ name = "type.storage.ocaml"; match = "\\<(int|char|float|string|list|array|mutable|ref|bool|unit|exn|option|int32|int64|nativeint|format4|lazy_t|type)\\>"; foregroundColor = "#6080ff"; },
		{ name = "name.module.open.ocaml"; match = "open\\s+([A-Z][a-zA-Z0-9_]*(\\.[A-Z][a-zA-Z0-9_]*)*)"; "fontStyle[1]" = ( bold ); "foregroundColor[1]" = "#ff8000"; },
		{ name = "name.module.ocaml"; match = "\\<([A-Z][a-zA-Z0-9_]*\\.)+"; fontStyle = ( bold ); foregroundColor = "#ff8000"; },
		{ name = "type.variant.ocaml"; match = "\\<[A-Z][a-zA-Z0-9_]*\\>"; fontStyle = ( bold ); foregroundColor = "#4080a0"; },
		{ name = "type.polyvariant.ocaml"; match = "\\<`[A-Z][a-zA-Z0-9_]*\\>"; fontStyle = ( bold ); foregroundColor = "#4080a0"; },
		{ name = "constant.numeric.ocaml"; match = "\\<((0(x|X)[0-9a-fA-F_]*)|(([0-9]+\\.?[0-9]*)|(\\.[0-9]+))((e|E)(\\+|-)?[0-9]+)?)(L|l)?|0(o|O)[0-7_]*|0(b|B)[01_]*\\>"; foregroundColor = "#40c0ff"; },
		{ name = "constant.string.ocaml"; begin = "(?=[^\\\\])(\")"; end = "\""; swallow = "\\\\."; foregroundColor = "#c03030"; },
		{ name = "constant.character.ocaml"; match = "'(\\\\x[a-fA-F0-9][a-fA-F0-9]|\\\\\\d\\d\\d|.|\\\\[bnrt'\"]|\\\\\\\\)'"; foregroundColor = "#ff8080"; },
		{ name = "constant.symbols.ocaml"; match = "[:\\(\\),;\\|&\\[\\]\\\{\\}@!]|\\<_\\>|<-|->"; foregroundColor = "#ffffa0"; },
		{ name = "constant.operators.ocaml"; match = "\\^{1,2}|(!|:)=|=(=|/)?|>=?/?|<(>|=?/?)|-(\\.|/)?|\\+(\\.|/)?|/(\\.|/)?|\\*(\\*/?|\\.|/)?|~(-\\.?)?|\\?|#"; foregroundColor = "#ffffa0"; },
		{ name = "keyword.directive.ocaml"; match = "^[ \\t]*#[a-zA-Z]+"; fontStyle = ( bold ); }
	);
}
